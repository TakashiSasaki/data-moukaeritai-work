# 各種 OS・ファイルシステムにおける日時表現方式の整理

このドキュメントは、本セッションで調査した **様々な OS やファイルシステムにおける日時表現の方式と分解能** をまとめたものです。
設計上の判断材料として「なぜ特定の単位が選択されたか」もあわせて解説します。

---

## 1. UNIX / POSIX 系

### 基本構造

* **`time_t`**

  * 元来は **秒単位**の整数（Unix Epoch: 1970-01-01 UTC 起点）。
  * 実装依存だが、古典的には 32bit 符号付き整数 → 2038年問題。
  * 64bit 移行により事実上無限に近い範囲をカバー。

### 高分解能 API

* **`gettimeofday(struct timeval)`**

  * 秒 (`time_t`) + マイクロ秒 (`suseconds_t`)
  * 分解能: µs 単位（10^-6 秒）。

* **`clock_gettime(struct timespec)`**

  * 秒 (`time_t`) + ナノ秒 (`long`)
  * 分解能: ns 単位（10^-9 秒）。
  * 実際のクロック精度は ms〜µs 程度に丸められることも多い。

### ファイルシステム

* **ext3**: 秒単位
* **ext4 / XFS / ZFS / APFS**: ns 単位で格納可能
* ただし API 呼び出しやハードウェアクロックに依存し、実際の精度は数 µs〜ms が多い。

---

## 2. Windows 系

### Win32 API

* **`FILETIME` 構造体**

  * 64bit 符号なし整数
  * 基点: 1601-01-01 UTC
  * 単位: **100ns (10^-7 秒)**
  * 範囲: 約 ±5840 万年

* **API**

  * `GetSystemTimeAsFileTime()`（従来精度、数 ms）
  * `GetSystemTimePreciseAsFileTime()`（高精度、Win8以降）

### ファイルシステム

* **FAT12/16/32**

  * ディレクトリエントリに日付/時刻を格納
  * 日付: 年(1980基点)/月/日
  * 時刻: 時/分/秒(2秒単位)
  * 分解能: **2 秒単位**
* **exFAT**

  * 10 ms 単位
* **NTFS**

  * 内部的に **FILETIME (100ns)** を使用
  * 実クロック精度は ms オーダーだが、仕様は初期から 100ns 単位

---

## 3. macOS / Darwin 系

* **古典的な Mac OS (HFS)**

  * 起点: 1904-01-01
  * 秒単位

* **macOS (Darwin / BSD由来)**

  * POSIX 互換 → `time_t` (秒)
  * `gettimeofday` / `clock_gettime` 利用可能 → µs/ns 単位

* **APFS**

  * ns 単位の精度をサポート

---

## 4. 古典的システム

* **MS-DOS / Windows 3.1**

  * FAT12/FAT16 を使用
  * 時刻分解能: **2秒単位**
  * atime（アクセス時刻）はなし、mtime のみ
* **Windows 95**

  * 内部 API は `FILETIME` (100ns) だが、FAT 上は 2秒単位に丸められる
* **Windows NT 系**

  * NTFS により、API の 100ns 精度がそのまま保存可能になった

---

## 5. 選択される単位の背景

### マイクロ秒 (µs)

* UNIX 系 `gettimeofday` の標準。
* 科学計測・高頻度イベントに実用十分。

### ナノ秒 (ns)

* POSIX `clock_gettime`、ext4/XFS/ZFS/APFS などの FS で採用。
* ただしハードウェア/OS のクロック分解能が追いつかない場合が多い。

### 100ns

* Windows NT 系と NTFS が採用。
* **理由**

  * VMS 由来の設計（DEC チーム出身）。
  * µs より細かく、ns ほど細かくない → 将来拡張を見据えた妥協。
  * 64bit 整数に収まりつつ非常に広い範囲を表現可能。
  * API・FS・レジストリなど OS 全体を一貫させる目的。

### 2秒単位

* FAT の設計制約（ディレクトリエントリのビット数節約）。
* 当時の PC 用途（フロッピー等）では十分とされた。

---

## 6. 比較表

| OS / FS         | 単位    | 基点   | 精度実態   | 備考            |
| --------------- | ----- | ---- | ------ | ------------- |
| UNIX `time_t`   | 秒     | 1970 | 1秒     | 32bit→2038年問題 |
| `gettimeofday`  | µs    | 1970 | 数µs〜ms |               |
| `clock_gettime` | ns    | 1970 | 数µs〜ms |               |
| FAT12/16/32     | 2秒    | 1980 | 2秒     | mtimeのみ       |
| exFAT           | 10ms  | 1980 | 10ms   |               |
| NTFS            | 100ns | 1601 | 数ms    | API/FS統一      |
| macOS HFS       | 秒     | 1904 | 1秒     |               |
| APFS            | ns    | 1970 | 数µs〜ms |               |

---

## 7. 設計上のガイドライン

* **互換性優先**

  * ファイル時刻やイベント記録用途なら **ms 精度**が最も実務的。
  * 多くの API (Java/JS/REST) が ms epoch を標準化。

* **高精度解析用**

  * 計測やログ順序性重視なら µs または ns。
  * ただし DB・FS に保存する際にはサイズ/インデックス効率も考慮。

* **Windows 互換優先**

  * ファイルメタデータ用途なら **100ns FILETIME** を直接保持する選択もあり。

* **古典 FS 互換**

  * FAT 系からの移行データは「2秒丸め」で扱う必要がある。

---

## 結論

* **FAT**：2秒精度という制約があった。
* **NTFS**：最初から 100ns 単位の仕様を持つ。
* **Unix 系**：µs → ns へ進化。
* **APFS/ext4 等**：ns 単位をサポート。

しかし **実クロック精度は ms オーダー**にとどまることが多く、
**DB用途やログ管理では「UTC・整数 ms epoch」が最も実用的で互換性が高い**。
特殊な計測用途以外では **ms 単位**を採用する設計が合理的といえる。
